# SCAR: A Verification Framework for Atom

SCAR stands for **S**earch **C**ompile **A**ssert **R**eport, it is a custom built framework for testing & verification of atom processor. Aim of building this framework was to unit-test each instruction to ensure its proper functioning. for ease of modification, SCAR is written in python.

This directory contains a verification framework to test the implementation of the atom processor (or any other RISC-V or non RISC-V processor). we'll refer to scar directory as `$ROOT`. 



## How does it work?

`$ROOT/scar.py` is the heart of the verification framework. When invoked, It goes through the following 4 steps:

1. **Search **: In this step, SCAR searches for assembly tests in the current directory. It looks fo all the files ending with a `.S` extension.
2. **Compile**: As the name suggests, In this step, SCAR compiles all the found tests into `.elf` files and stores them into `$OOT/work` directory.
3. **Assert**: In this step, scar loads elf files one-by-one into the atom-sim simulator in order to simulate them. Atom-sim is commanded to dump all its state into a `dump.txt` file, whenever it sees an `ebreak` instruction. This is done using `-ebreak-dump` flag. This generated dump-file contains all the state of the processor (PC, IR & registers x0-x31) at the time of encountering the `ebreak` instruction. This dump-file is read by scar and converted to a python-dictionary. scar also reads the source assembly file which has  to be annotated. The annotations present in the assembly file instruct scar to make certain assumptions about register values and cross-check the values using the dump-file. If all the assertions are met, The test passes, else the test fails with an `ASSERRTION FAILED!` error.
4. **Report**: Lastly scar generates a report of all the failed and passed tests.



## Annotating Assembly files

All assembly files in the test suite must be annotated with assertions. Assertions must always reside at the bottom of each assembly file. The region of file in which assertions are present is called assertion block. Start of annotation block is marked by `# $-ASSERTIONS-$` comment.

This must be followed by zero or more lines of assertions.

Example of an assembly file with assertions is given below:

```
.global _start

_start:
andi t0, t0, 0 # Clear register t0
andi t1, t1, 0 # Clear register t1
andi t2, t2, 0 # Clear register t2

li t0, 0xFF # Load a 8-bit number to t0
li t1, 0xFFFF # Load a 16-bit number to t1
li t2, 0xFFFFF343 # Load a 32-bit number to t2
li x3, 0x01234567

nop
ebreak
# $-ASSERTIONS-$
# eq t0 0x000000FF
# eq t1 0x0000FFFF
# eq t2 0xFFFFF343
# eq x3 0x01234567
```

These assertions are checked by scar framework only when atom-sim encounters the `ebreak`instuction, therefore assertions must be carefully chosen.

## Dump-file Format

dump-file must be in the form of a table with two columns and any number of rows. These columns must be separated by atleast 1 space character. The first coloumn must contain the name of the register/state & the second column must contain corresponding value. example of a dump-file generated by atom-sim is given below:

```
pc 0x0000011C
ir 0x00000013
x0 0x00000000
x1 0x00000000
x2 0x00000000
x3 0x00000000
x4 0x00000000
x5 0x10011000
x6 0x7B7A7971
x7 0x00000000
x8 0x00000000
x9 0x00000000
x10 0x00000000
x11 0x00000000
x12 0x00000000
x13 0x00000000
x14 0x00000000
x15 0x00000000
x16 0x00000000
x17 0x00000000
x18 0x00000000
x19 0x00000000
x20 0x00000000
x21 0x00000000
x22 0x00000000
x23 0x00000000
x24 0x00000000
x25 0x00000000
x26 0x00000000
x27 0x00000000
x28 0x00000000
x29 0x00000000
x30 0x00000000
x31 0x00000000
```



## Invoking SCAR

Although SCAR can be invoked simply by 

```
$ python3 scar.py
```

It is however suggested that the provided Makefile should be used:

```
$ make
```



### Example Output

```
$ make
python3 verify.py
|==============================================|
|      RISCV-Atom Verification framework       |                                           
|==============================================|                                           
  By: Saurabh Singh(saurabh.s99100@gmail.com)                                             
  
> Stage-1: Seaching for tests...
Found 6 tests
t1_li.S
t2_mv.S
t3_load_store_byte.S
t4_load_store_hw.S
t5_storew.S
t6_stored.S

> Stage-2: Compiling tests...
compile: t1_li.S: --- ok
compile: t2_mv.S: --- ok
compile: t3_load_store_byte.S: --- ok
compile: t4_load_store_hw.S: --- ok
compile: t5_storew.S: --- ok
compile: t6_stored.S: --- ok

> Stage-3: Executing & verifying dumps...
execute: /home/frozenalpha/git/riscv/riscv-atom/test/asm-test/work/t1_li.elf: --- ok
verify: t1_li.S: --- ok
execute: /home/frozenalpha/git/riscv/riscv-atom/test/asm-test/work/t2_mv.elf: --- ok
verify: t2_mv.S: --- ok
execute: /home/frozenalpha/git/riscv/riscv-atom/test/asm-test/work/t3_load_store_byte.elf: --- ok
verify: t3_load_store_byte.S: --- ok
execute: /home/frozenalpha/git/riscv/riscv-atom/test/asm-test/work/t4_load_store_hw.elf: --- ok
verify: t4_load_store_hw.S: ASSERTION FAILED! : 
Expected: a5 = 0xFFFF8999
Got:      a5 = 0x00008999
execute: /home/frozenalpha/git/riscv/riscv-atom/test/asm-test/work/t5_storew.elf: --- ok
verify: t5_storew.S: Skipping: no assertions!
execute: /home/frozenalpha/git/riscv/riscv-atom/test/asm-test/work/t6_stored.elf: --- ok
verify: t6_stored.S: Skipping: no assertions!

> Stage-4: Generating report...
|----------------------------|
|    Verification Report     |
|----------------------------|
Total tests  : 6

Passed tests : 5/6
        t1_li.S
        t2_mv.S
        t3_load_store_byte.S
        t5_storew.S
        t6_stored.S

Failed tests : 1/6
        t4_load_store_hw.S
```

